<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Water Simulation with Cesium Ion OSM Buildings</title>
    <style>
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.85/Build/Cesium/Cesium.js"></script>
    <script src="/3d_dev/libs/three/build/three.min.js"></script>
    <script src="/3d_dev/libs/water-material.js"></script>
</head>
<body>
    <div id="cesiumContainer" class="fullSize"></div>
    <script>
        // Initialize Cesium viewer
        var viewer = new Cesium.Viewer('cesiumContainer');

        // Initialize THREE.js scene for water
        var waterScene = new THREE.Scene();

        // Add water shader (provided earlier)

        // Create water object
        var water = new THREE.Water(viewer.scene.context.renderer, viewer.scene.camera, waterScene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: null,
            alpha: 1.0,
            sunDirection: new THREE.Vector3(0.70707, 0.70707, 0.0),
            sunColor: 0xffffff,
            waterColor: 0x7F7F7F,
            eye: new THREE.Vector3(0, 0, 0),
            distortionScale: 20.0,
            noiseScale: 1.0,
            side: THREE.FrontSide,
            fog: false
        });

        // Add water to water scene
        waterScene.add(water);

        // Load Cesium Ion OSM buildings 3D Tileset
        //var tilesetUrl = 'https://assets.cesium.com/4399/3dtiles/0/tileset.json'; // Example URL, replace with your own
        var tileset = viewer.scene.primitives.add(osmBuildingTileset//new Cesium.Cesium3DTileset({
        //     url: tilesetUrl
        // })
        );

        // Set camera to view the 3D Tileset
        viewer.zoomTo(tileset);

        // Render loop
        function render() {
            requestAnimationFrame(render);

            // Update water simulation
            water.material.uniforms.time.value += 1.0 / 60.0;

            // Update THREE.js renderer for water
            water.render();

            // Update Cesium viewer
            viewer.render();
        }
        render();
    </script>
</body>
</html> -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Terrain and OSM Buildings with Water</title>
    <style>
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="/3d_dev/libs/Cesium-1.117/Build/Cesium/Cesium.js"></script>
    <script src="/3d_dev/libs/three/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  
    <style>
        @import url(/3d_dev/libs/Cesium-1.117/Apps/Sandcastle/CesiumSandcastle.css);
    
        @import url(/3d_dev/libs/Cesium-1.117/Apps/Sandcastle/templates/bucket.css);
    </style>
</head>
<body>
    <div id="cesiumContainer" class="fullSize"></div>
    <script type="module">
        // Initialize Cesium viewer
        //var viewer = new Cesium.Viewer('cesiumContainer');
        Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmZjkyMzk4ZC1iMzdhLTRhNGMtYTAyMy1hNjE3YjMwMTQ3YTkiLCJpZCI6MTkwNTc2LCJpYXQiOjE3MTYyMDcwMzV9.K5Xn9YIdcDqEJnAsDm9tbMR8e_fURZ-Rn6jpMp7EDSI";
        // Load terrain
        // var terrainProvider = new Cesium.CesiumTerrainProvider({
        //     url: Cesium.IonResource.fromAssetId(1) // Replace with your terrain asset ID
        // });
        // viewer.terrainProvider = terrainProvider;

        // Load OSM buildings 3D Tileset
        // Cesium.createOsmBuildingsAsync().then((osmBuildingTileset) => {
        //             viewer.scene.primitives.add(osmBuildingTileset);});
        // var tilesetUrl = 'https://assets.cesium.com/4399/3dtiles/0/tileset.json'; // Example URL, replace with your own
        // var tileset = viewer.scene.primitives.add(
        //     new Cesium.Cesium3DTileset({
        //     url: tilesetUrl
        // }));

        // Set camera to view the 3D Tileset
        //viewer.zoomTo(tileset);
        // var viewer = new Cesium.Viewer('cesiumContainer', {
        //             terrain: Cesium.Terrain.fromWorldTerrain({
        //             requestWaterMask: true,
        //             }),
        //         });
            // Initialize Cesium viewer
            //var viewer = new Cesium.Viewer('cesiumContainer');
            var viewer = new Cesium.Viewer('cesiumContainer', {
                    terrain: Cesium.Terrain.fromWorldTerrain({
                    requestWaterMask: true,
                    }),
                });
            

            // // Create water plane geometry
            // var waterPlane = new Cesium.GeometryInstance({
            //     geometry : new Cesium.RectangleGeometry({
            //         rectangle : Cesium.Rectangle.fromDegrees(-61.40, 15.29, -61.37, 15.32), // Define the rectangle covering Roseau, Dominica
            //         height : 10,
            //         vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
            //     }),
            //     id : 'Water'
            // });

            // // Create water plane material
            // var waterMaterial = new Cesium.Material({
            //     fabric : {
            //         type : 'Water',
            //         uniforms : {
            //             normalMap : '/3d_dev/img/gnormal.jpg',
            //             frequency : 10000.0,
            //             animationSpeed : 0.01,
            //             amplitude : 10.0
            //         }
            //     }
            // });
            // Define the water material shader
        //     var waterMaterialShader = `
        //         uniform sampler2D u_waterTexture;
                
        //         void main() {
        //             vec2 st = fract(v_textureCoordinates);
                    
        //             // Sample the texture
        //             vec4 waterColor = texture2D(u_waterTexture, st);
                    
        //             // Apply the texture color to the material
        //             czm_materialInput materialInput;
        //             czm_material material = czm_getMaterial(materialInput);
        //             material.diffuse = waterColor.rgb;
                    
        //             // Set alpha to 1.0 to make the water fully opaque
        //             material.alpha = 1.0;
                    
        //             gl_FragColor = czm_phong(normalize(v_normal), -normalize(v_positionWC.xyz), material);
        //         }
        //     `;
        //     // Load your raster image texture
        //     var waterTextureUrl = '/3d_dev/img/wnormal.jpg';
        //     // Create a custom material
        //     var waterMaterial = new Cesium.Material({
        //         fabric: {
        //             uniforms: {
        //                 u_waterTexture: waterTextureUrl
        //             },
        //             source: waterMaterialShader
        //         }
        //     });
        //     // //Add water plane to the scene
        //     // viewer.scene.primitives.add(new Cesium.Primitive({
        //     //     geometryInstances : waterPlane,
        //     //     appearance : new Cesium.PerInstanceColorAppearance({
        //     //         translucent: true,
        //     //         closed: true
        //     //     }),
        //     //     releaseGeometryInstances: false,
        //     //     asynchronous: false,
        //     //     allowPicking: false
        //     // }));

        // // Create a water surface entity
        // var waterSurface = viewer.entities.add({
        //     name: 'Water Surface',
        //     position: Cesium.Cartesian3.fromDegrees(-61.376400, 15.304117), // Example position
        //     polygon: {
        //         hierarchy: Cesium.Cartesian3.fromDegreesArray([
        //             -75.0, 40.0,
        //             -80.0, 40.0,
        //             -80.0, 35.0,
        //             -75.0, 35.0
        //         ]),
        //         material: waterMaterial
        //     }
        // });

        // // Create a water surface primitive
        // var waterSurface = viewer.scene.primitives.add(new Cesium.Water({
        //     // Set position and dimensions of the water surface
        //     plane: new Cesium.Plane(Cesium.Cartesian3.UNIT_Z, 0.0),
        //     dimensions: new Cesium.Cartesian2(400000.0, 400000.0), // Set width and height of the water surface
        // }));

        // // Set material properties for the water surface
        // waterSurface.material = Cesium.Material.fromType('Water', {
        //     // Set water material parameters
        //     baseWaterColor: new Cesium.Color(0.1, 0.3, 0.8, 0.8),
        //     normalMap: '/3d_dev/img/wnormal.jpg' // Path to a normal map texture
        // });

        // // Optionally, adjust lighting conditions for the scene
        // viewer.scene.globe.enableLighting = true;
        // // Define the position of the water surface for zooming
        // var waterPosition = Cesium.Cartesian3.fromDegrees(-75.1642, 39.9526); // Example position

        // // Zoom to the location of the water surface
        // viewer.camera.flyTo({
        //     destination: Cesium.Cartesian3.fromElements(waterPosition.x, waterPosition.y, 10000.0),
        //     orientation: {
        //         heading: Cesium.Math.toRadians(0.0),
        //         pitch: Cesium.Math.toRadians(-45.0),
        //         roll: Cesium.Math.toRadians(0.0)
        //     },
        //     duration: 3 // Transition duration in seconds
        // });

        // Create a rectangle representing the water surface
// var waterRectangle = viewer.entities.add({
//     name: 'Water Surface',
//     rectangle: {
//         coordinates: Cesium.Rectangle.fromDegrees(-75.2, 39.8, -75.0, 40.0), // Example coordinates
//         height: 1000, // Water surface height (adjust as needed)
//         material: new Cesium.Material({
//             fabric: {
//                 type: 'Water',
//                 uniforms: {
//                     baseWaterColor: Cesium.Color.fromCssColorString('#336699').withAlpha(0.6),
//                     //specularMap: '/3d_dev/img/wnormal.jpg', // Path to a specular map texture
//                     //normalMap: '/3d_dev/img/wnormal.jpg' // Path to a normal map texture
//                 }
//             }
//         })
//     }
// });

// Zoom to the location of the water surface
//viewer.zoomTo(waterRectangle);

// Optionally, adjust lighting conditions for the scene
//viewer.scene.globe.enableLighting = true;
        //viewer.scene.skyAtmosphere.show = true;
        // let buildingTileset;
        // try {
        //             // buildingTileset = Cesium.Cesium3DTileset.fromIonAssetId(96188);
        //             // viewer.scene.primitives.add(buildingTileset);
        //     Cesium.createOsmBuildingsAsync().then((osmBuildingTileset) => {
        //     viewer.scene.primitives.add(osmBuildingTileset);
        //     });

        // } catch (error) {
        //     console.log(`Error loading building tileset. ${error}`);

        //     }
        //comment_13_06
        // var latitude = 15.304117;    // Roseau latitude
        // var longitude = -61.376450;  // Roseau longitude
        // const position = Cesium.Cartesian3.fromDegrees(longitude, latitude)
        // // var altitude = 100;
        // const heading = Cesium.Math.toRadians(90);
        // const pitch = Cesium.Math.toRadians(0);
        // const roll = Cesium.Math.toRadians(0);
        // const orientation = Cesium.Transforms.headingPitchRollQuaternion(
        //             position, new Cesium.HeadingPitchRoll(heading, pitch, roll)
        // );
        // var entity = viewer.entities.add({
        //     name: 'My Model',
        //     position: position,
        //     model: {
        //         uri: '/3d_dev/resources/3dscenes/exportsfld/flood_model_test_13_06_4.glb', // or .gltf
        //         color: new Cesium.Color(0.0, 0.0, 1.0, 0.5),
        //         orientation: orientation,
        //     },clampToTerrain: true,
        // });
        // Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmZjkyMzk4ZC1iMzdhLTRhNGMtYTAyMy1hNjE3YjMwMTQ3YTkiLCJpZCI6MTkwNTc2LCJpYXQiOjE3MTYyMDcwMzV9.K5Xn9YIdcDqEJnAsDm9tbMR8e_fURZ-Rn6jpMp7EDSI"
        // URL to your GLB model
    //const glbModelUrl = '/3d_dev/resources/3dscenes/exportsfld/flood_model_test_13_06_9.glb';
            // Function to load GLB model and extract transformations
    // function loadGLBModel(url) {
    //   return new Promise((resolve, reject) => {
    //     const loader = new THREE.GLTFLoader();
    //     loader.load(url, (gltf) => {
    //       const model = gltf.scene;
    //       const node = model.children[0];
    //       console.log(node)
    //       console.log(node.userData)
    //       // Log the extras to verify
    //       console.log('extras:', node.userData.extras);

    //     // //   // Extract custom properties for georeferencing
          
    // Function to load GLB model and extract transformations
    function loadGLBModel(url) {
      return new Promise((resolve, reject) => {
        const loader = new THREE.GLTFLoader();
        loader.load(url, (gltf) => {
          const model = gltf.scene;
          const node = model.children[0];
            
          // Log the extras to verify
          //console.log('extras:', node.userData.extras);

          // Ensure extras exists on the node
        //   const extras = node.userData.extras || {};
        //   const affineTransform = extras.affine_transform;
        //   const bounds = extras.bounds;
        const affineTransform = node.userData.affine_transform;
          const bounds = node.userData.bounds;

          if (!affineTransform || !bounds) {
            reject(new Error('Missing affine transform or bounds in extras'));
          } else {
            resolve({
              model: gltf,
              affineTransform: affineTransform,
              bounds: bounds
            });
          }
        }, undefined, reject);
      });
    }

    // Function to convert bounds to Cesium position
    function boundsToCesiumPosition(bounds) {
      const centerX = (bounds.min_x + bounds.max_x) / 2;
      const centerY = (bounds.min_y + bounds.max_y) / 2;

      return Cesium.Cartesian3.fromDegrees(centerX, centerY, 0);
    }

    // Load and place the model using its transformations
    async function loadAndPlaceModel(url) {
      try {
        const { model, affineTransform, bounds } = await loadGLBModel(url);

        const position = boundsToCesiumPosition(bounds);

        viewer.entities.add({
          name: 'GLTF Model from Metadata',
          position: position,
          model: {
            uri: url,
            minimumPixelSize: 128,
            maximumScale: 20000,
            color: new Cesium.Color(1.0, 0.0, 0.0, 1.0), // Red color
            colorBlendMode: Cesium.ColorBlendMode.REPLACE,
          }
        });

        // Fly the camera to the model
        viewer.flyTo(viewer.entities);
      } catch (error) {
        console.error('Error loading GLB model:', error);
      }
    }

    // Load the model using its transformations for positioning
    //loadAndPlaceModel(glbModelUrl);
        // Ensure extras exists on the node
        // const extras = node.userData.extras || {};
        //   const affineTransform = extras.affine_transform;
        //   const bounds = extras.bounds;
        // Ensure userData exists on the node
        // const userData = node.userData;
        //   const affineTransform = userData ? userData.affine_transform : null;
        //   const bounds = userData ? userData.bounds : null;

    //       if (!affineTransform || !bounds) {
    //         reject(new Error('Missing affine transform or bounds in extras'));
    //       } else {
    //         resolve({
    //           model: gltf,
    //           affineTransform: affineTransform,
    //           bounds: bounds
    //         });
    //       }
    //     }, undefined, reject);
    //   });
    // }
    // // Function to convert bounds to Cesium position
    // // function boundsToCesiumPosition(bounds) {
    // //   const centerLon = (bounds.min_lon + bounds.max_lon) / 2;
    // //   const centerLat = (bounds.min_lat + bounds.max_lat) / 2;

    // //   return Cesium.Cartesian3.fromDegrees(centerLon, centerLat, 0);
    // // }
    // // Function to convert bounds from meters to lat/lon
    // function boundsToLatLon(bounds) {
    //   const minPoint = new Cesium.Cartesian3(bounds.min_x, bounds.min_y, 0);
    //   const maxPoint = new Cesium.Cartesian3(bounds.max_x, bounds.max_y, 0);

    //   const ellipsoid = viewer.scene.globe.ellipsoid;
    //   const minCartographic = ellipsoid.cartesianToCartographic(minPoint);
    //   const maxCartographic = ellipsoid.cartesianToCartographic(maxPoint);

    // console.log(minPoint)
    //   const minLon = Cesium.Math.toDegrees(minCartographic.longitude);
    //   const minLat = Cesium.Math.toDegrees(minCartographic.latitude);
    //   const maxLon = Cesium.Math.toDegrees(maxCartographic.longitude);
    //   const maxLat = Cesium.Math.toDegrees(maxCartographic.latitude);

    //   return {
    //     min_lon: minLon,
    //     min_lat: minLat,
    //     max_lon: maxLon,
    //     max_lat: maxLat
    //   };
    // }

    // // Load and place the model using its transformations
    // async function loadAndPlaceModel(url) {
    //   try {
    //     const { model, affineTransform, bounds } = await loadGLBModel(url);

    //     const position = boundsToLatLon(bounds);
    //     console.log("position" , position)

    //     viewer.entities.add({
    //       name: 'GLTF Model from Metadata',
    //       position: Cesium.Cartesian3.fromDegrees((position.min_lon + position.max_lon) / 2, (position.min_lat + position.max_lat) / 2, 0),
    //       model: {
    //         uri: url,
    //         minimumPixelSize: 128,
    //         maximumScale: 20000,
    //         color: new Cesium.Color(1.0, 0.0, 0.0, 1.0), // Red color
    //         colorBlendMode: Cesium.ColorBlendMode.REPLACE,
    //       }
    //     });

    //     // Fly the camera to the model
    //     viewer.flyTo(viewer.entities);
    //   } catch (error) {
    //     console.error('Error loading GLB model:', error);
    //   }
    // }

    // // Load the model using its transformations for positioning
    // loadAndPlaceModel(glbModelUrl);

    // // Function to load GLB model and extract transformations
    // async function loadGLBModel(url) {
    //   return new Promise((resolve, reject) => {
    //     const loader = new THREE.GLTFLoader();
    //     loader.load(url, (gltf) => {
    //       const model = gltf.scene;

    //       // Assuming the first child has the transformation data
    //       const node = model.children[0];

    //       // Extract transformation data
    //       const position = node.position;
    //       const rotation = node.rotation;
    //       const scale = node.scale;

    //       resolve({
    //         position: position,
    //         rotation: rotation,
    //         scale: scale
    //       });
    //     }, undefined, reject);
    //   });
    // }

    // // Function to convert Three.js position to Cesium Cartesian3
    // function threePositionToCartesian3(position) {
    //   // Assuming the position is in meters
    //   // Convert the position to degrees
    //   const latitude = position.x;
    //   const longitude = position.y;
    //   const altitude = position.z;

    //   return Cesium.Cartesian3.fromDegrees(longitude, latitude, altitude);
    // }

    // // Function to convert Three.js rotation to Cesium quaternion
    // function threeRotationToQuaternion(rotation) {
    //   const quaternion = new THREE.Quaternion();
    //   quaternion.setFromEuler(rotation);
    //   return new Cesium.Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    // }

    // // Load and place the model using its transformations
    // async function loadAndPlaceModel(url) {
    //   try {
    //     const transform = await loadGLBModel(url);

    //     const position = threePositionToCartesian3(transform.position);
    //     const orientation = threeRotationToQuaternion(transform.rotation);

    //     viewer.entities.add({
    //       name: 'GLTF Model from Metadata',
    //       position: position,
    //       orientation: orientation,
    //       model: {
    //         uri: url,
    //         minimumPixelSize: 128,
    //         maximumScale: 20000,
    //         color: new Cesium.Color(1.0, 0.0, 0.0, 1.0), // Red color
    //         colorBlendMode: Cesium.ColorBlendMode.REPLACE,
    //       }
    //     });

    //     // Fly the camera to the model
    //     viewer.flyTo(viewer.entities);
    //   } catch (error) {
    //     console.error('Error loading GLB model:', error);
    //   }
    // }

    // // Load the model using its transformations for positioning
    // loadAndPlaceModel(glbModelUrl);
//comment_13_06_late

        // const resource = await Cesium.IonResource.fromAssetId(2621143);
        // const entity = viewer.entities.add({
        // model: { uri: resource,
        //     color: new Cesium.Color(0.0, 0.0, 1.0, 0.5),
        //  },clampToTerrain: true,
        // });
        //entity.model.scale = 32;
        //viewer.zoomTo(entity);
        // OSM Buildings
        let buildingTileset;
        try {
            buildingTileset = await Cesium.Cesium3DTileset.fromIonAssetId(
            96188);
            viewer.scene.primitives.add(buildingTileset);
            // const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(40866);
            // viewer.scene.primitives.add(tileset);


        } catch (error) {
        console.log(`Error loading building tileset.
        ${error}`);

        }
        //         viewer.scene.setTerrain(
//             new Cesium.Terrain(
//     Cesium.CesiumTerrainProvider.fromIonAssetId(2585459),
//   ),
// );
        
//         var provider = await Cesium.IonImageryProvider.fromAssetId(2585819);
//         var imageryLayer = viewer.imageryLayers.addImageryProvider(
//         provider,
//         );
//         const stage = new Cesium.PostProcessStage({
//         name: 'sharpen',
//         fragmentShader: [
//           'uniform sampler2D colorTexture;',
//           'uniform sampler2D depthTexture;',
//           'uniform bool test;',
//           'in vec2 v_textureCoordinates;',
//           'void main() {',
//           '    vec4 color = texture(colorTexture, v_textureCoordinates);',
//           '    vec4 prevColor = texture(colorTexture, v_textureCoordinates - vec2(1.0/512.0, 0.0));',
//           '    vec4 nextColor = texture(colorTexture, v_textureCoordinates + vec2(1.0/512.0, 0.0));',
//           '    vec4 topColor = texture(colorTexture, v_textureCoordinates - vec2(0.0, 1.0/512.0));',
//           '    vec4 bottomColor = texture(colorTexture, v_textureCoordinates + vec2(0.0, 1.0/512.0));',
//           '    vec4 centerColor = texture(colorTexture, v_textureCoordinates);',
//           '    vec4 avgColor = (prevColor + nextColor + topColor + bottomColor + centerColor) / 5.0;',
//           '    vec4 edge = centerColor - avgColor;',
//           '    vec4 sharpened = centerColor + 2.0 * edge;',
//           '    out_FragColor = vec4(sharpened.rgb, color.a);',
//           '}',
//         ].join('\n'),
//       });
//   viewer.scene.postProcessStages.add(stage);
  
        // Apply custom symbology with a custom shader
        //provider.then(function() {
        //     var customShader = new Cesium.CustomShader({
        //         fragmentShaderText: `
        //             void main() {
        //                 vec4 color = texture2D(u_texture, v_textureCoordinates);
        //                 // Convert to grayscale
        //                 float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        //                 // Apply custom color symbology (e.g., shades of blue)
        //                 gl_FragColor = vec4(0.0, 0.0, gray, color.a);
        //             }
        //         `
        //     });
        //     imageryLayer.customShader = customShader;
        // //});

        // // Rotate the model 90 degrees around the X-axis
        // entity.model.orientation = Cesium.Quaternion.fromAxisAngle(
        //     new Cesium.Cartesian3(1, 0, 0), 
        //     Cesium.Math.toRadians(-90)
        // );
        // Rotate the model 90 degrees around the X-axis
        // entity.model.modelMatrix = Cesium.Matrix4.fromRotationTranslation(
        //     Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(90)),
        //     entity.position
        // );
        // var pos1 = Cesium.Cartesian3.fromDegrees(longitude, latitude, altitude)
        // entity.model.orientation = Cesium.Transforms.headingPitchRollQuaternion(pos1, Cesium.Math.toRadians(0), Cesium.Math.toRadians(90), 0.0);
        // Set the initial camera view to Roseau, Dominica
        //console.log(entity)
        // var roseauPosition = Cesium.Cartesian3.fromDegrees(longitude, latitude, 1000); // Longitude, Latitude, Height
            // viewer.camera.flyTo({
            //     destination: roseauPosition,
            //     orientation: {
            //         heading: Cesium.Math.toRadians(0),
            //         pitch: Cesium.Math.toRadians(-45),
            //         roll: 0.0
            //     }
            // });
        // // Initialize THREE.js scene for water
        // var waterScene = new THREE.Scene();
        // var renderer = new THREE.WebGLRenderer({ alpha: true });
        // var waterPlane = new THREE.Mesh(
        //     new THREE.PlaneGeometry(1000, 1000),
        //     new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 })
        // );
        // waterPlane.rotation.x = -Math.PI / 2;
        // waterScene.add(waterPlane);

        // // Create water animation loop
        // function animateWater() {
        //     requestAnimationFrame(animateWater);
        //     // Update water animation here
        //     renderer.render(waterScene, viewer.camera);
        // }
        // animateWater();
        // Initialize THREE.js scene for water
        // var waterScene = new THREE.Scene();
        // var renderer = new THREE.WebGLRenderer({ alpha: true });
        // var waterPlane = new THREE.Mesh(
        //     new THREE.PlaneGeometry(1000, 1000),
        //     new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 })
        // );
        // waterPlane.rotation.x = -Math.PI / 2;
        // waterScene.add(waterPlane);

        // // Create a camera for THREE.js that mimics the Cesium camera's position and orientation
        // var threeCamera = new THREE.PerspectiveCamera();
        // threeCamera.position.set(viewer.camera.position.x, viewer.camera.position.y, viewer.camera.position.z);
        // threeCamera.rotation.set(viewer.camera.heading, viewer.camera.pitch, viewer.camera.roll);

        // // Create water animation loop
        // function animateWater() {
        //     requestAnimationFrame(animateWater);
        //     // Update water animation here
        //     renderer.render(waterScene, threeCamera);
        // }
        // animateWater();


        // // Get the Cartesian coordinates of Roseau, Dominica
        // var roseauPosition = Cesium.Cartesian3.fromDegrees(-61.7500, 15.3000);

        // // Create THREE.js scene for water
        // var waterScene = new THREE.Scene();

        // // Create water plane
        // var waterPlaneGeometry = new THREE.PlaneGeometry(2000, 2000);
        // var waterPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 });
        // var waterPlane = new THREE.Mesh(waterPlaneGeometry, waterPlaneMaterial);
        // waterPlane.rotation.x = -Math.PI / 2;

        // // Position the water plane over Roseau
        // var roseauCartographic = Cesium.Cartographic.fromCartesian(roseauPosition);
        // var waterPlanePosition = Cesium.Cartesian3.fromRadians(roseauCartographic.longitude, roseauCartographic.latitude, 0);
        // waterPlane.position.copy(waterPlanePosition);

        // // Add water plane to the THREE.js scene
        // waterScene.add(waterPlane);

        // // Render loop
        // function render() {
        //     requestAnimationFrame(render);

        //     // Update Cesium viewer
        //     viewer.render();

        //     // Update THREE.js renderer for water
        //     // Since there's no water simulation in this example, we don't need to update the water scene
        // }
        // render();
    function createModel(url, height) {
        //viewer.entities.removeAll();

        const position = Cesium.Cartesian3.fromDegrees(//-61.37184, 15.30451,roseau
          //-61.37808,15.31574 ,
          //-61.46170, 15.3000, 
          -61.451490, 15.460817,
        // -61.4516,
        // 15.4604,
          height
        );
      
        const heading = Cesium.Math.toRadians(90);
        const pitch = 0;
        const roll = 0;
        const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
          position,
          hpr
  );

  const entity = viewer.entities.add({
    name: url,
    position: position,
    orientation: orientation,
    model: {
      uri: url,
      minimumPixelSize: 128,
      maximumScale: 20000,
      // color: Cesium.Color.DEEPSKYBLUE.withAlpha(0.8),
      // colorBlendMode: Cesium.ColorBlendMode.MIX,
      // scale: 20, 
    },
  });
  viewer.trackedEntity = entity;
  entity.polygon = {
        heightReference: Cesium.HeightReference.CLAMP_TO_TERRAIN
    };

  
console.log("pos1", position)

console.log("entity", entity)
}

//const resource = await Cesium.IonResource.fromAssetId(2621143);
      createModel(
        "bef.glb",
        200
      );
      createModel(
        "aft.glb",
        400.0
      );
      //createModel(resource, 0.0);
      
// const entity1 = viewer.entities.add({
//   model: { uri: resource },
// });
//viewer.trackedEntity = entity1;
    </script>
</body>
</html>
